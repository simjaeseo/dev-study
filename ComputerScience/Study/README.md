# **CS Study**

### 참고 자료

- [velog](https://velog.io/@minsgy/%EB%B0%B1%EC%97%94%EB%93%9C-%EA%B0%9C%EB%B0%9C%EC%9E%90-%EB%A9%B4%EC%A0%91%ED%95%99%EC%8A%B5%EB%82%B4%EC%9A%A9)

## 목차

> - [스프링](#스프링)
> - [자바](#자바)
> - [보안](#보안)
> - [운영체제](#운영체제)
>   
>   > - [프로세스와 스레드의 차이는 무엇인가요?](#프로세스와-스레드의-차이는-무엇인가요)
>   > - [교착상태란 무엇이며, 교착상태가 발생하기 위해서는 어떤 조건이 있어야 하나요?](#교착상태란-무엇이며-교착상태가-발생하기-위해서는-어떤-조건이-있어야-하나요)
>   > - [교착상태의 해결법은 무엇인가요?](#교착상태의-해결법은-무엇인가요)
>   > - [뮤텍스와 세마포어에 대해서 설명해 보시오](#뮤텍스와-세마포어에-대해서-설명해-보시오)
>   > - [컨텍스트 스위칭이란 무엇인가요?](#컨텍스트-스위칭이란-무엇인가요)
>   > - [경쟁 상태란 무엇인가요?](#경쟁-상태란-무엇인가요)

<br>

---

## 스프링

<br>

## 자바

<br>

## 보안

<br>

## 운영체제

<br>

> ### 프로세스와 스레드의 차이는 무엇인가요
> 
> <br>
> 
> ✨ 정리
> 
> > 프로세스는 프로그램 실행에 필요한 내용이 메모리에 적재되어 운영체제로부터 자원을 할당 받은 작업에 단위이며, 스레드는 프로세스 내에서 실행되는 흐름의 단위입니다. 프로세스 사이에서는 자원을 공유하지않지만, 스레드는 서로 Heap 영역의 자원을 공유합니다.
> 
> <br>
> 
> ❗ 프로그램
> 
> > - 어떤 작업을 하기 위해 처리방법과 순서를 기술한 명령문 집합체
> > - 프로그램을 실행 -> 프로세스 인스턴스 생성!
> 
> <br>
> 
> ❗ 프로세스
> 
> > 프로그램 실행에 필요한 내용이 메모리에 적재되어 운영체제로부터 자원을 할당 받은 작업의 단위
> 
> <br>
> 
> ❗ 스레드
> 
> > - 어떠한 프로세스 내에서 실행되는 흐름의 단위
> > - 스레드들 프로세스 내에서 각각 stack만 따로 할당받고 Code, Data, Heap 영역은 공유!

<br>

[목차로 이동](#목차)

<br>

> ### 교착상태란 무엇이며 교착상태가 발생하기 위해서는 어떤 조건이 있어야 하나요
> 
> <br>
> 
> ✨ 정리
> 
> > 교착상태란 두 개 이상의 프로세스나 스레드가 서로 필요한 자원을 모두 얻지 못해서 무한히 다음 자원을 기다리게 되는 상태입니다. 
> > 
> > 교착상태가 발생하기위한 조건은 상호배제, 점유 대기, 비선점, 순환대기로 총 네개이며 모두 성립되어야합니다. 
> 
> <br>
> 
> ❗ 교착상태 (DeadLock)
> 
> > - 두 개 이상의 프로세스나 스레드가 서로 자원을 얻지 못해서 다음 처리를 하지 못하는 상태
> > - 무한히 다음 자원을 기다리게 되는 상태
> > - 교착상태가 일어나는 경우
> > 
> > ![image](https://user-images.githubusercontent.com/63089631/197149839-04219b2b-fd25-44b1-a322-7130220883e2.png)
> > 
> > > 프로세스1, 2가 자원1, 2를 모두 얻어야 한다고 가정!
> > > 
> > > ​    
> > > 
> > > t1 : 프로세스1이 자원1을 얻음 / 프로세스2가 자원2를 얻음
> > > 
> > > t2 : 프로세스1은 자원2를 기다림 / 프로세스2는 자원1을 기다림
> > > 
> > > ​    
> > > 
> > > 현재 서로 원하는 자원이 상대방에 할당되어 있어서, 두 프로세스는 무한정 wait 상태에 빠짐
> 
> <br>
> 
> ❗ 교착상태 발생 조건
> 
> > - 4가지 모두 성립해야 데드락 발생!
> > 
> > > 하나라도 성립하지않으면 해결 가능!
> > 
> > 1. 상호 배제(Mutual exclusion)
> > 
> > > - 자원은 한번에 한 프로세스만 사용할 수 있음
> > 
> > 2. 점유 대기(Hold and wait)
> > 
> > > - 최소한 하나의 자원을 점유하고 있으면서 다른 프로세스에 할당되어 사용하고 있는 자원을 추가로 점유하기 위해 대기하는 프로세스가 존재해야 함
> > 
> > 3. 비선점(No preemption)
> > 
> > > - 다른 프로세스에 할당된 자원은 사용이 끝날 때까지 강제로 빼앗을 수 없음
> > 
> > 4. 순환 대기(Circular wait)
> > 
> > > - 프로세스의 집합에서 순환 형태로 자원을 대기하고 있어야 함

<br>

[목차로 이동](#목차)

<br>

> ### 교착상태의 해결법은 무엇인가요
> 
> <br>
> 
> > ✨ 정리
> > 
> > > 교착상태의 해결법은 예방, 회피, 발견, 회복이 있습니다. 예방은 교착 상태 발생 조건을 하나 제거하고, 회피는 자원 할당 후 문제 없는지 확인합니다. 발견은 데드락이 발생하면 빠르게 문제 해결하는 것이고 회복은 교착상태에 놓인 프로세스를 종료하거나 할당을 해제하는 것입니다.
> 
> <br>
> 
> ❗ 교착상태의 해결법
> 
> > 1. 예방
> > 
> > > - 교착 상태가 발생하기 전에 미리 조치를 취하는 방식
> > > 
> > > - 교착 상태 발생 조건 중 하나를 제거함으로써 해결
> > > 
> > > - 자원 낭비가 심함
> > > 
> > > > 1. 모든 **자원 공유** 허용
> > > > 2. 모든 자원에 대해 **선점 허용**
> > > > 3. 필요 자원을 **한 번에 모두 할당**하기
> > > > 4. **자원에게 순서 부여**를 통해 프로세스 순서의 증가 방향으로만 자원 요청
> > 
> > 2. 회피
> > 
> > > - 프로세스가 자원을 요구할 때, 시스템은 자원을 할당한 후에도 안정 상태로 남아있는가를 확인하여 교착 상태를 회피
> > > - 오버헤드가 많이 발생
> > > 
> > > > ex) 은행원 알고리즘(Banker's Algorithm)
> > > > 
> > > > > - 안정 상태면 자원 할당, 아니면 다른 프로세스들이 자원 해지까지 대기
> > 
> > 3. 발견
> > 
> > > - 데드락이 발생하면 빠르게 발견하고 문제를 해결하는 것
> > > 
> > > > 자원 할당 그래프(Resource Allocation Graph)를 통해 교착 상태 탐지
> > > > 
> > > > ![image](https://user-images.githubusercontent.com/63089631/197308531-a372a927-ebbb-44c5-82a4-4f820756f305.png)
> > 
> > 4. 회복
> > 
> > > - 교착 상태를 일으킨 프로세스를 종료하거나 할당된 자원을 해제하면서 회복
> > > 
> > > > 1. 프로세스 종료 방법
> > > > 
> > > > > - 교착 상태의 프로세스 모두 중지
> > > > 
> > > > > - 교착 상태가 제거될 때까지 한 프로세스씩 중지
> > > > 
> > > > 2. 자원 선점 방법
> > > > 
> > > > > - 자원을 빼앗긴 프로세스는 강제 종류 이후 재시작
> > > > 
> > > > > - 교착 상태에 빠진 프로세스가 필요로 하는 자원을 강제로 가져옴
> 
> <br>
> 
> <br>
> 
> [출처_velog](https://velog.io/@yanghl98/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9COS-Deadlock%EB%8D%B0%EB%93%9C%EB%9D%BD-%EC%A0%95%EC%9D%98-%EB%B0%9C%EC%83%9D-%EC%A1%B0%EA%B1%B4-%ED%95%B4%EA%B2%B0-%EB%B0%A9%EB%B2%95)

<br>

[목차로 이동](#목차)

<br>

> ### 뮤텍스와 세마포어에 대해서 설명해 보시오
> 
> ✨ 정리
> 
> > 세마포어와 뮤텍스는 여러 프로세스나 쓰레드가 공유 자원에 접근하는 것을 제어하기 위한 방법입니다. 
> > 
> > 뮤텍스는 공유된 자원에 대해 하나의 프로세스 혹은 스레드만이 접근 가능하며, 세마포어는 세마포어 변수 만큼 여러 프로세스 혹은 스레드가 접근이 가능합니다.
> > 
> > 또, 세마포어는 현재 수행중인 프로세스가 아닌 다른 프로세스가 세마포어를 해제할 수 있지만, 뮤텍스는 락을 획득한 프로세스만이 락 해제가 가능합니다.   
> 
> <br>
> 
> ❗ 들어가기 전
> 
> > 1. **공유된 자원에 여러 개의 프로세스 혹은 스레드가 동시에 접근하면 Critical Section**(여러 프로세스가 데이터를 공유하며 수행될 때, 각 프로세스에서 공유 데이터를 접근하는 프로그램 코드 블록) **문제가 발생**할 수 있다. 
> > 2. 이를 해결하기 위해 **공유 자원을 한 번에 하나의 프로세스 혹은 레드만만 접근할 수 있도록 제한을 두는 동기화 방식**을 취해야 한다.   
> 
> <br>
> 
> ❗ 뮤텍스 (Mutex)
> 
> > - 공유된 자원의 데이터 혹은 임계영역(Critical Section) 등에 **하나의** **Process 혹은 Thread만 접근 가능** (동기화 대상이 하나, 서로 겹치지 않게)
> > - **한 프로세스에 의해 소유될 수 있는 Key를 기반**으로 한 상호배제 기법
> > 
> > > - **Key에 해당하는 객체를 소유한 스레드/프로세스만이** 공유자원에 접근 가능
> > 
> > ![image](https://user-images.githubusercontent.com/63089631/197338098-85f3ea83-f551-426e-97d4-b4d885408ca0.png)
> 
> <br>
> 
> ❗ 세마포어 (Semaphore)
> 
> > - 공유된 자원의 데이터 혹은 임계영역(Critical Section) 등에 세마포어의 변수만큼 **여러 Process 혹은 Thread가 접근가능** (동기화 대상이 하나 이상)
> > 
> > - 자원을 사용하지 않는 상태가 될 때, 대기하던 프로세스가 즉시 자원을 사용하고. 이미 다른 프로세스에 의해 사용중이라는 사실을 알게 되면, 재시도 전에 일정시간 대기해야 함
> > 
> > - 일반적으로 비교적 긴 시간을 확보하는 리소스에 대해 사용
> 
> <br>
> 
> ❗ 차이점
> 
> > - Mutex는 동기화 대상이 오직 **1개일 때** 사용하며, Semaphore는 동기화 대상이 **1개 이상일 때** 사용합니다.
> > - Mutex는 **자원을 소유할 수 있고**, 책임을 가지는 반면 Semaphore는 **자원 소유가 불가**합니다.
> > - Mutex는 상태가 0, 1 뿐이므로 Lock을 가질 수 있고, 소유하고 있는 스레드만이 이 Mutex를 해제할 수 있습니다. 반면 Semaphore는 Semaphore를 소유하지 않는 스레드가 Semaphore를 해제할 수 있습니다.
> > - Semaphore는 시스템 범위에 걸쳐 있고, 파일 시스템 상의 파일로 존재합니다. 반면, Mutex는 프로세스의 범위를 가지며 프로세스 종료될 때 자동으로 Clean up 됩니다.
> 
> <br>
> 
> <br>
> 
> [출처_티스토리](https://delpho.tistory.com/29?category=943516)

<br>

[목차로 이동](#목차)

<br>

> ### 컨텍스트 스위칭이란 무엇인가요?
> 
> > ✨ 정리
> > 
> > > - CPU가 어떤 프로세스를 실행하고 있는 상태에서 OS의 스케쥴러가 인터럽트를 진행하여 더 높은 우선순위를 가진 프로세스가 실행되어야 할 때, 스케쥴러가 레지스터에 저장된 기존 프로세스 값들을 커널 내부에 존재하는 PCB에 저장하고, 새 프로세스의 값을 PCB에서 다시 가져와서 교체하는 작업
> > 
> > <br>
> > 
> > ❗ 컨텍스트 스위칭
> > 
> > > - CPU가 어떤 프로세스를 실행하고 있는 상태에서 OS의 스케쥴러가 인터럽트를 진행하여 더 높은 우선순위를 가진 프로세스가 실행되어야 할 때, 스케쥴러가 레지스터에 저장된 기존 프로세스 값들을 커널 내부에 존재하는 PCB에 저장하고, 새 프로세스의 값을 PCB에서 다시 가져와서 교체하는 작업
> > 
> > <br>
> > 
> > ❗ 콘텍스트 스위칭이 발생하는 상황
> > 
> > > 1. 입/출력을 요청할 때
> > > 2. CPU 사용시간이 만료되었을 때
> > > 3. 자식 프로세스를 만들 때
> > > 4. 인터럽트 처리를 기다릴 때
> > 
> > <br> ❗ 단점
> > 
> > > - 잦게 발생할수록 오버헤드(Overhead) 비용이 발생하여 성능이 떨어짐
> > > 
> > > ![image](https://user-images.githubusercontent.com/63089631/197340570-2247554b-cd9f-418d-a53d-cbbbff0730e2.png)
> > > 
> > > - 위 그림에서, 프로세스 P0가 실행 중인 상태(excuting)에서 유휴 상태(idle)가 될 때 프로세스 P1이 곧바로 excuting이 되지 않고 idle을 좀 더 하다가 excuting이 된다.
> > > 
> > > >  이유 👉👉 프로세스 P0의 상태를 PCB에 저장하고 프로세스 P1 상태를 PCB에서 가져와야 하기 때문
> > > 
> > > >  그런데, 이 과정에서 PCB를 저장하고 가져올 때 CPU는 아무런 일도 하지 못하게 된다.
> 
> [출처_티스토리](https://delpho.tistory.com/25?category=943516)

<br>

[목차로 이동](#목차)

<br>

> ### 경쟁 상태란 무엇인가요
> 
> > ✨ 정리
> > 
> > > 교착상태의 한 종류로, <u>**프로세스가 어떤 순서로 데이터에 접근하느냐에 따라 결과값이 달라질 수 있는 상황**</u>입니다.
> > 
> > <br>
> > 
> > 
> > ❗ 경쟁 상태 (Race Condition)
> > 
> > > - 프로세스가 어떤 순서로 데이터에 접근하느냐에 따라 결과값이 달라질 수 있는 상황
> > > - 둘 이상의 입력이나 조작이 동시에 일어나 의도하지 않은 결과를 가져오는 경우
> > > - 동시 접근 시 자료의 일관성을 해치는 결과가 나타날 수 있음
> > > - 경쟁 상태도 교착상태의 종류 중에 하나
> 
> <br>
> 
> [출처_티스토리](https://delpho.tistory.com/25?category=943516)

<br>

[목차로 이동](#목차)

<br>

